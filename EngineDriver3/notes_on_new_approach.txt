

New approach:
single activity with multiple dynafrags:
  exactly 1 of: prefs, connect, about
  1 to n: throttle
  0 to n: turnouts, routes, web (trains, panels, frames, etc.)
the activity will be recreated on rotation.  its job is to set up the
  tabs, drawermenu, dynafrags and the permafrag
all inter-process comm is via handler messages, to allow for queuing
application object has getters and setters for all shared entities
shared variable setters should send "xx_CHANGED" messages to the activity,
  which can forward to any active dynafrags or the permafrag which need to see it
each dynafrag should handle its own preferences, and remember them
persistent storage will be sharedpreferences, storing json strings for objects
permafrag is not recreated on rotation, only first time activity starts
permafrag is the only one who starts, talks to, or stops the threads
some threads are continuous, some end when they've finished their update
some threads allowed to update shared entities directly, clearly document these
threads only talk to permafrag, not to activity or dynafrags
long-running threads use handler looper for control and looping
shared list of dynafrags is used by activity, each dynafrag backrefs its handler when active, and
  clears when not, so activity doesn't try to send messages to inactive frags
dynafrags should do very little "work", mostly ui, nothing needing SHUTDOWN, consider them transient
dynafrags should _read_ from shared variables, letting the permafrag handle all updates to them
shared objects are maintained by the threads, dynafrags send XX_REQUESTED messages,
  threads respond with XX_CHANGED messages, UI is (re)drawn based on shared items
all comm with jmri is done via the json websocket server, including lists of items.
"Add a Tab" menu item should present a smart list of possibilities, some hard-coded, some from panel list, etc.
"Remove a Tab" should present a smart list of possibilities, e.g. don't show Connect
use dialogFragments for tasks which do not need a tab, such as fragment settings, select loco, etc.
use nested fragments for stacking multiple throttle fragments inside a single tab

steps:
1) get single activity with multiple, similar "listview" fragments working at OS 3.0, and understand how fragment width works.
2) add application state variables, starting with fragment list  Note: I plan to only use get/set for access to these, to provide for read-time checks.
3) add 3rd-party, back-level support for ActionBar.  Not sure I want to go all the way back to 1.6, but I'd at least like to be able to run this on my Nook and my wife's old phone.
4) add webviewFragment, with hard-coded url, and begin to understand how to handle the loading and running of differing fragments.  also understand webview fling vs. fragment fling
5) set up webviewFragments for About, Turnout and Routes (using the JMRIMobile pages)  url still hard-coded
6) set Throttle to use webThrottle
7) create separate classes for each fragment type, with unique data and methods in each
8) remove Sherlock and rewrite for Android Support
9) add a PermaFragment to handle all async stuff
10) add LONG_MESSAGE and SHORT_MESSAGE messages, for showing as toast by activity
11) create and manage jmdns thread for jmdns listeners
12) add Connect fragment
13) figure out how to send the new server name to activity, and how to forward on to all "interested" fragments
14) add jmdns listeners, updating discovered list in Connect fragment.
15) add initial websocket reader/writer
16) have server-dependent web fragments rebuild on CONNECTED
17) create Turnout and Route Fragments,
18) add background roster details retrieval
19) prompt for app exit on back only if connected. (only if locos are acquired?)
20) add refresh button to web fragments
21) save/restore fragment list+settings on activity create and pause
22) open drawer menu when hardware button pressed
23) add dialogs, called from drawer menu, to add new fragments and delete unneeded ones.
24) add proper throttle fragment
25) determine if various throttle "flavors" should be settings for a single fragment type, or multiple fragment types.
26) add address/roster selection/entry dialog
27) determine messaging flow between selectloco, websockets, throttle fragments
28) allow one fragment to be the default for portrait, and one for landscape,
    to provide the current "auto-web on rotation" feature.  Connect is default when not connected.
29) add notification icon and action
) add power button to title bar
) add settings icon to each fragment, (dropping hard-coded urls) and store as json shared prefs
) add phone listener, option to pause locos
) add more throttle flavors

things to "improve" from ED 2.x:
more flexible UI to take advantage of screen real estates
multiple versions of throttle, including vertical and shunting, make new ones easy to add
use nonUIFragment to handle activity restarts on rotation
use tabbed sliders for navigation
use json sharedprefs instead of text file storage
use json server instead of withrottle server
cleanup/rethink thread structure, use fewer patterns, avoid threads starting threads
loss of connection should be more obvious, clearing screens, etc.
move code into separate members whenever possible, vs. adding everything to TA and mainapp
always use set()/get() vs. direct access to shared variables
use an object-oriented design where possible
eliminate the "copies" of members and method currently used to support three throttles (xxT, xxS, xxG)
improve jmdns discovery, including on quick exit and restart

document old structure:
ta.onCreate starts comm_thread
  comm_thread.commm_handler starts socket_WiT thread
  comm_thread.process_response puts out and in timers on queue
  comm_thread.process_response creates and uses ClockWebSocket (on "W")
ta.onCreate creates download meta and roster tasks
comm_thread.process_response fires download meta and roster tasks
each activity plus comm_thread has a message_handler, with pointer stored in mainapp
comm_thread.comm_handler starts/stops jmdns listener

Notes:
onSaveInstanceState can be used for fragments to "remember" what they were doing thru orientation changes, frag switches, etc.
fragments are very transient, (except for PermaFrag), which is why you avoid fragment to fragment comm
the activity can "lookup" each fragment by position, positioning to the frag will create it (if needed)
fragments update their handler ref, which activity uses to determine if fragment is alive or not
not sure how best to handle Throttles in this new transient dynafrag world.
web pages will also reload on fragment switch, which may need to be addressed
minSDK is 8 due to AutoBahn WebSocket library
listadapters are limited to fairly simple hashmaps, so the shared lists will be robust objects, then copied to a
  local list, sorted, filtered, etc. by the ui fragment.
the gson converter failed with StackOverflowError on some devices when I tried to convert rich objects, so
  I convert them to simple HashMaps, with any pointers removed, and save/restore those instead

Shared objects:
discovered server list (maintained by jmdns thread, read only by ConnectFrag)
current connection and ports (null if not connected) (maintained by websocket thread and permafrag)
turnout list with states, maintained by websocket thread, read only by TurnoutFragment
route list with states, maintained by websocket thread, read only by RoutesFragment
roster list with details
layout power state (maintained by websocket thread, read by activity on POWER_STATE_CHANGED)
fast clock time (maintained by websocket thread, read by activity on JMRI_TIME_CHANGED)
recent locos list (one instance, maintained by all ThrottleFrags, stored in sharedprefs)
metadata (railroad name, jmri version, etc.) (stored on connection by websocket thread)
throttleList (list of Throttle objects in use by various throttleFrags)
DefaultFunctions (text, number and momentary flag) for Fn buttons, to use when no roster entry is available. TODO: where maintained?
RecentThrottleList (list of addresses and consists which have been recently used) maintained by permafrag

Not Shared objects (stored as json in sharedprefs):
recent server list (maintained by ConnectFrag, stored in sharedprefs as json)
Consist (singleton local to each throttlefrag, which keeps track of 0-n Throttle objects attached to frag)

ConnectFrag:
Reads: discoveredServersList
Sends: CONNECT_REQUESTED (address, port)
Recvs: DISCOVERED_SERVER_LIST_CHANGED, CONNECTED, DISCONNECTED
Saves: recentServersList

TurnoutFrag:
Reads: turnoutsList
Sends: TURNOUT_CHANGE_REQUESTED (name, newstate)
Recvs: TURNOUT_LIST_CHANGED

ThrottleFrag:
Reads: throttleList entry (keyed by a new throttleKey)
Sends: LOCO_REQUESTED (throttleKey, locoAddress, rosterID, relativeDirection, fragName)
  THROTTLE_VELOCITY_CHANGE_REQUESTED (throttleKey, throttleSpeed, throttleDirection)
  THROTTLE_FN_CHANGE_REQUESTED (throttleKey, Fn#, newState)
  LOCO_FN_CHANGE_REQUESTED (locoAddress/throttleKey, Fn#, newState)
  RELEASE_LOCO_REQUESTED (fragName, throttleKey)
Recvs: THROTTLE_STATE_CHANGED (throttleKey)
  LOCO_RELEASED (fragName)
Saves: DefaultFnList, RecentThrottleList (since these are shared, maybe let permafrag save them)

global throttleList of Throttle objects:
  keyed by throttleKey, which is dcc address as a string
  stores data about a single jmri "throttle" object, keyed by throttleKey, which is dcc address as a string
  keeps a list of fragments which use this throttle
  Throttle speed and direction are maintained from the server response for the lead loco, not the UI request
  Throttles will be updated even if their corresponding frag is inactive
  jsonserver has an element called "throttle" which is used as a key to a single jmri Throttle
   object.
  the server response will be by ThrottleKey, so updates could be applied to just the lead loco,
    every loco, ??
  F0 will be assumed to be headlight, and requests adjusted to turn off lights on trailing locos, based
    on leadloco direction  (make this a pref?)
  All ThrottleFragments will use the same object, but differing layout files.  The layout name to use will be
    passed/stored in the data parm of each fragment. file name is "throttle_xxxx.xml" where xxxx is the selected layout.
  The id names of the various parts of each throttle layout will be the same.  Code should accept missing ids.
  The "functions" buttons are added to the layout dynamically, to best handle screen size changes.
  FnKeys are based on lead loco for Consist.  if not defined, a default list is shown.

Consist object, local to each throttleFrag
  has a list of throttles, 0-n
  first loco treated as "lead", last treated as "trail".  rearrange the sequence to change this
  the Consist has a speed and direction, and each loco can have a relative direction and speed adjustment
  Consist speed and direction are updated from server response for the lead loco.
  throttles are added to Consist when acquired from server, or by a direct message from websocketthread
    if already allocated for another throttlefrag
  throttles are removed from Consist when released from server, or by a direct message if used by >1 frag
  Throttles are removed from global list first, so Consists are asked to "verify" themselves to remove missing throttles

Redesign of Select Loco dialog
  numeric input at top, with Acquire button
  buttons for sort and toggle between roster and recents
  maybe allow sort of roster by recent use
  numeric input also works as dynamic filter for lists


