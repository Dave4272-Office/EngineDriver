New approach:
single activity with multiple dynafrags:
  exactly 1 of: prefs, connect, about
  1 to n: throttle
  0 to n: turnouts, routes, web (trains, panels, frames, etc.)
the activity will be recreated on rotation.  its job is simply to
  set up the tabs, dynafrags and the permafrag
permafrag is not recreated on rotation, only first time activity starts
dynafrags should do very little "work", mostly ui, nothing needing SHUTDOWN, consider them transient
dynafrags should _read_ from shared variables, letting the permafrag handle all updates to them
permafrag should send "xx_CHANGED" messages to the activity,
  which can forward to any active dynafrags which need to see it
permafrag is the only one who starts, talks to, or stops the threads
some threads are continuous, some end when they've finished their update
some threads allowed to update shared entities directly (maybe?)
all inter-process comm is via handler messages, to allow for queuing
application object has getters and setters for shared entities (maybe?)
each dynafrag should handle its own preferences, and remember them

steps:
1) get single activity with multiple, similar "listview" fragments working at OS 3.0, and understand how fragment width works.
2) add application state variables, starting with fragment list  Note: I plan to only use get/set for access to these, to provide for read-time checks.
3) add 3rd-party, back-level support for ActionBar.  Not sure I want to go all the way back to 1.6, but I'd at least like to be able to run this on my Nook and my wife's old phone.
4) add webviewFragment, with hard-coded url, and begin to understand how to handle the loading and running of differing fragments.  also understand webview fling vs. fragment fling
5) set up webviewFragments for About, Turnout and Routes (using the JMRIMobile pages)  url still hard-coded
6) set Throttle to use webThrottle
7) create separate classes for each fragment type, with unique data and methods in each
8) add a RetainedTaskFragment to handle all async stuff
) add Connect fragment, to simply set the server name, to be used by web fragments
) figure out how to send the new server name to activity, and how to forward on to all "interested" fragments
) add refresh button to web fragments
) add settings icon to each fragment, (dropping hard-coded urls) and deal with persistent storage.
) add mechanism to add new fragments and delete unneeded ones.  fragment list+settings should be restored on app start.
) add initial socket reader/writer.  (re)position to Connect when no connection, Determine if Application object should "own" these async tasks, vs. fragment or activity.  Determine if handler is still the best way to communicate with them.
) add jmdns listeners, updating discovered list in Connect fragment.
) add proper throttle fragment (hard-coded address), get communication working
) add address/roster selection/entry dialog (determine if activity or fragment or popup dialog, or whatever)
) add background roster details retrieval (maybe using json server?)
) determine if various throttle "flavors" should be settings for a single fragment type, or multiple fragment types.
) add additional throttle flavors
) replace Turnout and Route webviewFragments with listFragments,
) enable webfrag's back button, remember url and zoom
) make webfrag width a pref
) prompt for app exit on back

things to "improve" from ED 2.x
more flexible UI to take advantage of screen real estates
use nonUIFragment to handle activity restarts on rotation
use tabbed sliders for navigation
use database instead of text file storage
use Service for comm stuff (maybe not?)
use json server in addition to (or instead of) withrottle server
cleanup/rethink thread structure, use fewer patterns
loss of connection should be more obvious

document old structure:
ta.onCreate starts comm_thread
  comm_thread.commm_handler starts socket_WiT thread
  comm_thread.process_response puts out and in timers on queue
  comm_thread.process_response creates and uses ClockWebSocket (on "W")
ta.onCreate creates download meta and roster tasks
comm_thread.process_response fires download meta and roster tasks
each activity plus comm_thread has a message_handler, with pointer stored in mainapp
comm_thread.comm_handler starts/stops jmdns listener

Notes:
onSaveInstanceState can be used for fragments to "remember" what they were doing.
fragments are transient, (except for Retained), which is why you avoid fragment to fragment comm
the activity can "lookup" each fragment by position, this will build it (if needed)
#13 shows setCommunicator(this)
not sure how best to handle Throttles in this new transient dynafrag world.

Shared objects:
discovered server list
recent server list
current connection and ports (null if not connected)
turnout list with states
route list with states
roster list with details
recent locos list
layout power state
metadata (jmri version, etc.)
fast clock time
