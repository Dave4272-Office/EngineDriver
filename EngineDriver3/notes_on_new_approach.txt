New approach:
single activity with multiple dynafrags:
  exactly 1 of: prefs, connect, about
  1 to n: throttle
  0 to n: turnouts, routes, web (trains, panels, frames, etc.)
the activity will be recreated on rotation.  its job is to set up the
  tabs, drawermenu, dynafrags and the permafrag
all inter-process comm is via handler messages, to allow for queuing
application object has getters and setters for all shared entities
shared variable setters should send "xx_CHANGED" messages to the activity,
  which can forward to any active dynafrags or the permafrag which need to see it
each dynafrag should handle its own preferences, and remember them
persistent storage will be sharedpreferences, storing json strings for objects
permafrag is not recreated on rotation, only first time activity starts
permafrag is the only one who starts, talks to, or stops the threads
some threads are continuous, some end when they've finished their update
some threads allowed to update shared entities directly, clearly document these
threads only talk to permafrag, not to activity or dynafrags
long-running threads use handler looper for control and looping
shared list of dynafrags is used by activity, each dynafrag backrefs its handler when active, and
  clears when not, so activity doesn't try to send messages to inactive frags
dynafrags should do very little "work", mostly ui, nothing needing SHUTDOWN, consider them transient
dynafrags should _read_ from shared variables, letting the permafrag handle all updates to them
all comm with jmri is done via the json websocket server, including lists of items.
"Add a Tab" menu item should present a smart list of possibilities, some hard-coded, some from panel list, etc.
"Remove a Tab" should present a smart list of possibilities, e.g. don't show Connect
use dialogFragments for tasks which do not need a tab, such as fragment settings
use nested fragments for stacking multiple throttle fragments inside a single tab

steps:
1) get single activity with multiple, similar "listview" fragments working at OS 3.0, and understand how fragment width works.
2) add application state variables, starting with fragment list  Note: I plan to only use get/set for access to these, to provide for read-time checks.
3) add 3rd-party, back-level support for ActionBar.  Not sure I want to go all the way back to 1.6, but I'd at least like to be able to run this on my Nook and my wife's old phone.
4) add webviewFragment, with hard-coded url, and begin to understand how to handle the loading and running of differing fragments.  also understand webview fling vs. fragment fling
5) set up webviewFragments for About, Turnout and Routes (using the JMRIMobile pages)  url still hard-coded
6) set Throttle to use webThrottle
7) create separate classes for each fragment type, with unique data and methods in each
8) remove Sherlock and rewrite for Android Support
9) add a PermaFragment to handle all async stuff
10) add LONG_MESSAGE and SHORT_MESSAGE messages, for showing as toast by activity
11) create and manage jmdns thread for jmdns listeners
12) add Connect fragment
13) figure out how to send the new server name to activity, and how to forward on to all "interested" fragments
14) add jmdns listeners, updating discovered list in Connect fragment.
15) add initial websocket reader/writer
16) have server-dependent web fragments rebuild on CONNECTED
17) create Turnout and Route Fragments,
18) add background roster details retrieval
19) prompt for app exit on back only if connected. (only if locos are acquired?)
20) add refresh button to web fragments
21) save/restore fragment list+settings on activity create and pause
22) open drawer menu when hardware button pressed
23) add dialogs, called from drawer menu, to add new fragments and delete unneeded ones.
) allow one fragment to be the default for portrait, and one for landscape,
    to provide the current "auto-web on rotation" feature.  Only when connected.
) add notification icon and action
) add power button to title bar
) add settings icon to each fragment, (dropping hard-coded urls) and store as json shared prefs
) add proper throttle fragment (hard-coded address)
) add address/roster selection/entry dialog (determine if activity or fragment or popup dialog, or whatever)
) determine if various throttle "flavors" should be settings for a single fragment type, or multiple fragment types.
) add additional throttle flavors
) add phone listener

things to "improve" from ED 2.x:
more flexible UI to take advantage of screen real estates
multiple versions of throttle, including vertical and shunting
use nonUIFragment to handle activity restarts on rotation
use tabbed sliders for navigation
use json sharedprefs instead of text file storage
use json server instead of withrottle server
cleanup/rethink thread structure, use fewer patterns, avoid threads starting threads
loss of connection should be more obvious, clearing screens, etc.
move code into separate members whenever possible, vs. adding everything to TA and mainapp
always use set()/get() vs. direct access to shared variables
use an object-oriented design where possible
eliminate the "copies" of members and method currently used to support three throttles (xxT, xxS, xxG)
improve jmdns discovery, including on quick exit and restart

document old structure:
ta.onCreate starts comm_thread
  comm_thread.commm_handler starts socket_WiT thread
  comm_thread.process_response puts out and in timers on queue
  comm_thread.process_response creates and uses ClockWebSocket (on "W")
ta.onCreate creates download meta and roster tasks
comm_thread.process_response fires download meta and roster tasks
each activity plus comm_thread has a message_handler, with pointer stored in mainapp
comm_thread.comm_handler starts/stops jmdns listener

Notes:
onSaveInstanceState can be used for fragments to "remember" what they were doing thru orientation changes, frag switches, etc.
fragments are very transient, (except for PermaFrag), which is why you avoid fragment to fragment comm
the activity can "lookup" each fragment by position, positioning to the frag will create it (if needed)
fragments update their handler ref, which activity uses to determine if fragment is alive or not
not sure how best to handle Throttles in this new transient dynafrag world.
web pages will also reload on fragment switch, which may need to be addressed
minSDK is 8 due to AutoBahn WebSocket library
listadapters are limited to fairly simple hashmaps, so the shared lists will be robust objects, then copied to a
  local list, sorted, filtered, etc. by the ui fragment.
the gson converter failed with StackOverflowError on some devices when I tried to convert rich objects, so
  I convert them to simple HashMaps, with any pointers removed, and save/restore those instead

Shared objects:
discovered server list (maintained by jmdns thread, read only by ConnectFrag)
current connection and ports (null if not connected) (maintained by websocket thread and permafrag)
turnout list with states, maintained by websocket thread, read only by TurnoutFragment
route list with states, maintained by websocket thread, read only by RoutesFragment
roster list with details
layout power state (maintained by websocket thread, read by activity on POWER_STATE_CHANGED)
fast clock time (maintained by websocket thread, read by activity on JMRI_TIME_CHANGED)
recent locos list (one instance, maintained by all ThrottleFrags, stored in sharedprefs)
metadata (railroad name, jmri version, etc.) (stored on connection by websocket thread)
throttleList (list of Throttle objects in use by various throttleFrags)
DefaultFunctions (text, number and momentary flag) for Fn buttons, to use when no roster entry is available. TODO: where maintained?
RecentConsistList (list of addresses and consists which have been recently used) maintained by permafrag

Not Shared objects (stored as json in sharedprefs):
recent server list (maintained by ConnectFrag, stored in sharedprefs as json)

ConnectFrag:
Reads: discoveredServersList
Sends: CONNECT_REQUESTED (address, port)
Recvs: DISCOVERED_SERVER_LIST_CHANGED, CONNECTED, DISCONNECTED
Saves: recentServersList

TurnoutFrag:
Reads: turnoutsList
Sends: TURNOUT_CHANGE_REQUESTED (name, newstate)
Recvs: TURNOUT_LIST_CHANGED

NOTE: using name Consist instead of Throttle avoid confusion with single Throttle object in jmri
ConsistFrag:
Reads: consistList entry (keyed by a new consistID)
Sends: ADD_LOCO_REQUESTED (consistID, locoAddress/rosterID, relativeDirection)
  CONSIST_VELOCITY_CHANGE_REQUESTED (consistID, consistSpeed, consistDirection)
  CONSIST_FN_CHANGE_REQUESTED (consistID, Fn#, newState)
  LOCO_FN_CHANGE_REQUESTED (locoAddress/rosterID, Fn#, newState)
Recvs: CONSIST_STATE_CHANGED (consistID)
Saves: DefaultFnList, RecentConsistList (since these are shared, maybe let permafrag save them)

Consist object:
  stores data about a single "consist", assigned to a single slider+buttons UI fragment
  each Consist has a unique ConsistID, used to map the frag to the object
  Consist will have 1:n locos, in a specified sequence (defined by UI)
  first loco treated as "lead", last treated as "trail".  rearrange the sequence to change this
  the Consist has a speed and direction, and each loco has a relative direction and speed adjustment
  consist speed and direction are maintained from the server response for the lead loco, not the UI request
  Consists will be updated even if their corresponding frag is inactive
  jsonserver has an element called "throttle" which is used as a key to a single jmri Throttle
   object. websocketthread will generate this key as ConsistID+LocoID.
  websocketthread splits the UI request for changes and sends for each loco in consist, changing as needed
  the server response will be by ConsistID+LocoID, so updates could be applied to just the lead loco,
    every loco, ??
  F0 will be assumed to be headlight, and requests adjusted to turn off lights on trailing locos, based
    on consist direction  (make this a pref?)

