New approach:
single activity with multiple dynafrags:
  exactly 1 of: prefs, connect, about
  1 to n: throttle
  0 to n: turnouts, routes, web (trains, panels, frames, etc.)
the activity will be recreated on rotation.  its job is simply to
  set up the tabs, dynafrags and the permafrag
all inter-process comm is via handler messages, to allow for queuing
application object has getters and setters for all shared entities
shared variable setters should send "xx_CHANGED" messages to the activity,
  which can forward to any active dynafrags or the permafrag which need to see it
each dynafrag should handle its own preferences, and remember them
persistent storage will be sharedpreferences, storing json strings for objects
permafrag is not recreated on rotation, only first time activity starts
permafrag is the only one who starts, talks to, or stops the threads
some threads are continuous, some end when they've finished their update
some threads allowed to update shared entities directly, clearly document these
threads only talk to permafrag, not to activity or dynafrags
long-running threads use handler looper for control and looping
shared list of dynafrags is used by activity, each dynafrag backrefs its handler when active, and
  clears when not, so activity doesn't try to send messages to inactive frags
dynafrags should do very little "work", mostly ui, nothing needing SHUTDOWN, consider them transient
dynafrags should _read_ from shared variables, letting the permafrag handle all updates to them
all comm with jmri is done via the json websocket server, including lists of items.

steps:
1) get single activity with multiple, similar "listview" fragments working at OS 3.0, and understand how fragment width works.
2) add application state variables, starting with fragment list  Note: I plan to only use get/set for access to these, to provide for read-time checks.
3) add 3rd-party, back-level support for ActionBar.  Not sure I want to go all the way back to 1.6, but I'd at least like to be able to run this on my Nook and my wife's old phone.
4) add webviewFragment, with hard-coded url, and begin to understand how to handle the loading and running of differing fragments.  also understand webview fling vs. fragment fling
5) set up webviewFragments for About, Turnout and Routes (using the JMRIMobile pages)  url still hard-coded
6) set Throttle to use webThrottle
7) create separate classes for each fragment type, with unique data and methods in each
8) remove Sherlock and rewrite for Android Support
9) add a PermaFragment to handle all async stuff
10) add LONG_MESSAGE and SHORT_MESSAGE messages, for showing as toast by activity
11) create and manage jmdns thread for jmdns listeners
12) add Connect fragment
13) figure out how to send the new server name to activity, and how to forward on to all "interested" fragments
14) add jmdns listeners, updating discovered list in Connect fragment.
15) add initial websocket reader/writer
16) have server-dependent web fragments rebuild on CONNECTED
17) create Turnout and Route Fragments,
) add power button to title bar
) add refresh button to web fragments
) add settings icon to each fragment, (dropping hard-coded urls) and deal with persistent storage.
) add mechanism to add new fragments and delete unneeded ones.  fragment list+settings should be restored on app start.
) add proper throttle fragment (hard-coded address), get communication working
) add address/roster selection/entry dialog (determine if activity or fragment or popup dialog, or whatever)
) add background roster details retrieval (maybe using json server?)
) determine if various throttle "flavors" should be settings for a single fragment type, or multiple fragment types.
) add additional throttle flavors
) enable webfrag's back button, remember url and zoom
) make webfrag width a pref
) prompt for app exit on back
) add notification icon and action
) add phone listener


things to "improve" from ED 2.x
more flexible UI to take advantage of screen real estates
use nonUIFragment to handle activity restarts on rotation
use tabbed sliders for navigation
use database instead of text file storage (or even better, json sharedprefs)
use Service for comm stuff (maybe not?)
use json server in addition to (or instead of) withrottle server
cleanup/rethink thread structure, use fewer patterns
loss of connection should be more obvious
move code into separate members whenever possible, vs. adding everything to TA and mainapp
improve jmdns discovery, including on quick exit and restart


document old structure:
ta.onCreate starts comm_thread
  comm_thread.commm_handler starts socket_WiT thread
  comm_thread.process_response puts out and in timers on queue
  comm_thread.process_response creates and uses ClockWebSocket (on "W")
ta.onCreate creates download meta and roster tasks
comm_thread.process_response fires download meta and roster tasks
each activity plus comm_thread has a message_handler, with pointer stored in mainapp
comm_thread.comm_handler starts/stops jmdns listener

Notes:
onSaveInstanceState can be used for fragments to "remember" what they were doing.
fragments are very transient, (except for PermaFrag), which is why you avoid fragment to fragment comm
the activity can "lookup" each fragment by position, this will build it (if needed)
fragments update their handler ref, which activity uses to determine if fragment is alive or not
not sure how best to handle Throttles in this new transient dynafrag world.
minSDK is 8 due to AutoBahn WebSocket library
listadapters are limited to fairly simple hashmaps, so the shared lists will be more robust, then copied to a
  local list, sorted, filtered, etc. by the ui fragment.

Shared objects:
discovered server list (maintained by jmdns thread, read only by ConnectFrag)
current connection and ports (null if not connected) (maintained by websocket thread and permafrag)
turnout list with states, maintained by websocket thread, read only by TurnoutFragment
route list with states, maintained by websocket thread, read only by RoutesFragment
roster list with details
layout power state (maintained by websocket thread, read by activity on POWER_STATE_CHANGED)
metadata (jmri version, etc.) (stored on connection by websocket thread)
fast clock time (maintained by websocket thread, read by activity on JMRI_TIME_CHANGED)
recent locos list (one instance, maintained by all ThrottleFrags, stored in sharedprefs)

Not Shared objects:
recent server list (maintained by ConnectFrag, stored in sharedprefs)

ConnectFrag:
Reads: discoveredServersList
Sends: CONNECT_REQUESTED
Recvs: DISCOVERED_SERVER_LIST_CHANGED, CONNECTED, DISCONNECTED
Local: recentServersList

TurnoutFrag:
Reads: turnoutsList
Sends: TURNOUT_CHANGE_REQUESTED
Recvs: TURNOUT_LIST_CHANGED, TURNOUT_CHANGED (maybe)


